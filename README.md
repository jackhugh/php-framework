# php-framework

An implementation of a basic MVC php framework, inspired by express and laravel.

## Table of Contents

- [Installation](#installation)
- [Router](#router)
- [Route](#route)
- [Request and Response](#request-and-response)
- [Controller](#controller)
- [View](#view)
- [Middleware](#middleware)
- [HTTPException](#httpexception)
- [Error Handling](#error-handling)

## Installation

The included docker-compose means you can get a web server up and running straight away. Ports can be changed in `.env`.

```bash
docker-compose up -d
```

If you do not wish to use docker then you can just clone this repo and serve with your own web server.

### PHP 8

This framework makes use of new php features such as constructor property promotion and match expressions; as such PHP 8 is required.

## Router

The router maps an HTTP verb and URI path to a predefined route.

Create a router and add a route.

```php
// App/routes.php
use Core\Router;

$router = new Router();

$router->addRoute($route);
```

Once all routes have been added the router can be dispatched. It will first execute any globally registered middleware followed by iterating through all routers and routes (in order of creation) until it finds a match. The router will then run all router and route specific middleware followed by the controller method attached to the route. If no matching route can be found then a 404 HTTPException will be thrown.

```php
Router::dispatch($_SERVER['REQUEST_METHOD'], parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH));
```

## Route

A route defines how a request will map to a controller. Route has a factory built in for the 5 main HTTP verbs.

```php
use Core\Route;

Route::GET(string $path, \ReflectionMethod $controller, string $type = "HTML");
Route::POST(string $path, \ReflectionMethod $controller, string $type = "HTML");
Route::PUT(string $path, \ReflectionMethod $controller, string $type = "HTML");
Route::PATCH(string $path, \ReflectionMethod $controller, string $type = "HTML");
Route::DELETE(string $path, \ReflectionMethod $controller, string $type = "HTML");
```

An instance of `ReflectionMethod` can easily be generated by using the `Controller::method` factory.

Some examples

```php
// Create a route for 'GET' requests to '/' that will invoke Homepage::show.
$route = Route::GET('/', Homepage::method('show'));

// Create a route for 'POST' requests to '/sumbit' that will invoke Form::submit and return a JSON response.
$route = Route::POST('/submit', Form::method('submit'), "JSON");
```

Route paths can contain parameters by enclosing the parameter name in curly braces. If matched, the value will be passed with the parameter name via the `Request` object to the controller.

```php
$route = Route::GET('/user/{username}', User::method('show'));
```

## Request and Response

The request and response objects are core to the framework and are passed around to be accessed and mutated as needed.

### Request

Request contains all the important information about the current request.

| Name                | Type     | Description                           |
| ------------------- | -------- | ------------------------------------- |
| `$request->url`     | string   | The current route relative to root.   |
| `$request->method`  | string   | HTTP method.                          |
| `$request->params`  | stdClass | All route parameters indexed by name. |
| `$request->query`   | stdClass | Copy of `(object) $_GET`.             |
| `$request->post`    | stdClass | Copy of `(object) $_POST`.            |
| `$request->cookies` | stdClass | Copy of `(object) $_COOKIE`.          |

### Response

Response contains several properties that can be mutated.

| Name                               | Type   | Description                              |
| ---------------------------------- | ------ | ---------------------------------------- |
| `$response->type`                  | string | Response type - default "HTML"           |
| `$response->headers`               | array  | Array of headers indexed by header name. |
| `$response->responseCode`          | int    | Response code - default 200.             |
| `$response->body`                  | string | Response body.                           |
| `$response->redirect(string $url)` | method | Redirect to URL and terminate execution. |
| `$response->send()`                | method | Send response and terminate execution.   |

## Controller

Controllers contain all of your core logic and can be created by extending `\Core\Controller`. Controllers are instantiated with `Request` and `Response` which can be mutated and are available as controller properties.

```php
// App\Controllers\User.php
use \Core\Controller;

class User extends Controller {
	public function show() {
		$data = [
			'user' => $this->request->params->username
		];
		return View::render('user.phtml', $data);
	}
}
```

The return value from the method will automatically set the response body.

By default routes are set to HTML which can be rendered easily using `View::render`.

If the route has been set to JSON then any data can be returned and will be automatically encoded using `json_encode`.

## View

View::render provides an easy way to sanetize and inject variables into templates and returns pure HTML.

```php
View::render(string $filename, array $data = [], bool $sanetize = true);
```

The `$filename` should be relative to `App/views/` and the `$data` array contains values indexed by variable name. By default it will sanetize all input according to `htmlentities()` but can be disabled by passing false as a third argument.

```php
$data = [
	'username' => $this->request->params->username
];
View::render('user.phtml', $data);
```

```html
/* App/views/user.phtml */
<html>
	<body>
		User is
		<?= $username ?>
	</body>
</html>
```

## Middleware

Middleware can created by implementing `\Core\Middleware`. The necessary `Middleware::run` method is passed a `Request` and `Response` object which can be mutated before being passed onto the next middleware or finally controller. Alternatively this chain can be broken by invoking `Response::send`.

An example middlware that adds a custom header to all responses.

```php
// App/Middleware/CustomHeader.php
use Core\Middleware;

class CustomHeader implements Middleware {
	public function run(Request $req, Response $resp) {
		$resp->headers['X-Custom-Header'] = 'some value';
	}
}

// App/routes.php
use \App\Middleware\CustomHeader;

Router::addStaticMiddleware(new CustomHeader());
```

Middleware can be added in a number of ways.

Added directly to `Router` - these are always run, even if a route cannot be found.

```php
Router::addStaticMiddleware($middleware);
```

Added to instances of `Router`.

```php
$router->addMiddleware($middleware);
```

Added to an individual `Route`.

```php
$route->addMiddleware($middleware);
```

## HTTPException

An HTTPException can be thrown at any point in the script to generate an appropriate response for that route. If no message is given it will try to find a matching response for that HTTP code.

```php
throw new \Core\Exceptions\HTTPException(401, "You are not authorized");
```

## Error Handling

If exceptions are allowed to bubble up then the router will catch anything that extends `\Throwable` and pass onto `App\Controllers\Error` to handle.

If the exception is not an HTTPException then it will evaluate whether `$ENV['ENVIRONMENT']` matches `dev`. If true it will rethrow the error, else it will generate an HTTPException(500).

The controller then generates a response based on the route type. If there is no route then a HTML response will be created. HTML responses use the `error.phtml` template.
